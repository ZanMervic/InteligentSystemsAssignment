maze1 = c("##E##",
"#...#",
"#...#",
"#S..#",
"#####")
maze1
map_reading <- function(map){
}
maze1
maze1[1]
maze1[1,1]
maze1[1:1]
maze1[1][1]
x <- c("a", "b", "c", "d")
# replacing an element
x[2] <- "BBBBB"
x[c(1,3)] <- c("AAAAA", "CCCCC")
maze[1]
maze1[1]
maze1[1,2]
strsplit(maze1[1], "")
maze1 = c("##E##",
"#...#",
"#...#",
"#S..#",
"#####")
strsplit(maze1[1], "")
map_reading <- function(maze){
rows = length(maze)
columns = nchar(maze[1])
maze_matrix = matrix(, nrow = rows, ncol = columns)
maze_matrix[x] = strsplit(maze[x], "")
}
temp <- map_reading(maze1)
map_reading <- function(maze){
rows = length(maze)
columns = nchar(maze[1])
maze_matrix = matrix(, nrow = rows, ncol = columns)
for (x in 1:rows + 1) {
maze_matrix[x] = strsplit(maze[x], "")
}
}
temp <- map_reading(maze1)
temp
length(maze1)
length(maze1[1])
nchar(maze[1])
nchar(maze1[1])
nchar(maze1)
nchar(maze1)
maze2 = c("#####E#",
"#.#.#.#",
"#.....#",
"##.####",
"#....S#",
"#.#..##",
"#######")
nchar(maze2)
length(maze2[1])
length(maze2)
maze[1]
maze1[1]
strsplit(maze1[1], "")
map_reading <- function(maze){
rows = length(maze)
columns = nchar(maze[1])
maze_matrix = strsplit(maze[1], "")
for (i in c(2:rows + 1)) {
maze_matrix <- rbind(maze_matrix, strsplit(maze[i], ""))
}
}
temp = map_reading(maze1)
temp
temp <- map_reading(maze1)
map_reading <- function(maze){
rows = length(maze)
columns = nchar(maze[1])
maze_matrix = strsplit(maze[1], "")
for (i in c(2:rows + 1)) {
maze_matrix <- rbind(maze_matrix, strsplit(maze[i], ""))
}
return maze_matrix
}
map_reading <- function(maze){
rows = length(maze)
columns = nchar(maze[1])
maze_matrix = strsplit(maze[1], "")
for (i in c(2:rows + 1)) {
maze_matrix <- rbind(maze_matrix, strsplit(maze[i], ""))
}
return (maze_matrix)
}
temp <- map_reading(maze1)
temp
temp[1]
temp[1,1]
temp[1,2]
temp[1,1]
temp[1][1]
temp[1]
temp
maze_matrix = strsplit(maze1[1],"")
maze_matrix
maze_matrix <- rbind(maze_matrix, strsplit(maze[2], ""))
maze_matrix <- rbind(maze_matrix, strsplit(maze1[2], ""))
maze_matrix
kanta = matrix(, 5, 6)
kanta
kanta[1] = strsplit(maze1[1])
kanta[1] = strsplit(maze1[1],"")
kanta
kanta = matrix(, 5, 6)
kanta[1,:] = strsplit(maze1[1],"")
kanta
kanta = matrix(1:30, 5, 6)
kanta
kanta[1,1]
kanta[1,5]
temp <- c(1,2,3,4,5,6)
temp
temp
kanta <- cbind(kanta, temp)
temp <- matrix( 1:6, 1,6)
temp
kanta <- cbind(kanta, temp)
temp <- matrix( 1:6, 1,6)
temp <- t(temp)
kanta <- cbind(kanta, temp)
temp <- matrix( 1:5,5,1)
kanta <- cbind(kanta, temp)
kanta
kanta
kanta[1,1]
kanta[1,6]
kanta[1,7]
map_reading <- function(maze){
'In mazer.r all mazes are square shaped so we might only need the rows parameter'
rows = length(maze)
columns = nchar(maze[1])
'We initialize an empty matrix of the correct dimensions'
maze_matrix = matrix(, nrow = rows, ncol = columns)
'We fill the matrix with correct values'
for (i in c(1:rows)) {
maze_matrix[i,] <- unlist(strsplit(maze[i], ""))
}
return (maze_matrix)
}
stats <- function(path, maze){
maze_matrix = map_reading(maze)
'Dobimo vektor koordinat zacetne pozicije'
start <- as.vector(t(which(maze_matrix == 'S', arr.ind = TRUE)))
exit <- as.vector(t(which(maze_matrix == 'E', arr.ind = TRUE)))
current = start
'Gremo skozi celoten vektor (po 2 bita pretvorimo v move) in spreminjamo trenutno lokacijo, ter preverjamo veljavnost koraka'
for (i in seq(1,length(path), 2)) {
'We get the next move'
move <- path[c(i:i+1)]
'We adjust the current position accordingly'
if(all(move == c(0,0))){ "UP"
current <- current - c(1,0)
} else if(all(move == c(0,1))){ "RIGHT"
current <- current + c(0,1)
} else if(all(move == c(1,0))){ "DOWN"
current <- current + c(1,0)
} else if(all(move == c(1,1))){ "LEFT"
current <- current - c(0,1)
} else{
print("Error")
}
if(!all(current > 0) || !all(current < dim(maze_matrix) || maze_matrix(current[1], current[2]) == '#')){
'We are either out of a matrix or on a wall'
'We can add if we get to "S" which would mean we are going in a loop and its not the shortest position'
'We can give all enteties 0 if this happens or we can count how many walls they go through and give a value based on that'
print("INVALID MOVE")
}
if(maze_matrix[current[1], current[2]] == 'E'){
print("MADE IT TO THE FINISH")
break
}
}
'All moves were done or we got to the exit'
print(current)
}
library(GA)
map_reading <- function(maze){
'In mazer.r all mazes are square shaped so we might only need the rows parameter'
rows = length(maze)
columns = nchar(maze[1])
'We initialize an empty matrix of the correct dimensions'
maze_matrix = matrix(, nrow = rows, ncol = columns)
'We fill the matrix with correct values'
for (i in c(1:rows)) {
maze_matrix[i,] <- unlist(strsplit(maze[i], ""))
}
return (maze_matrix)
}
stats <- function(path, maze){
maze_matrix = map_reading(maze)
'Dobimo vektor koordinat zacetne pozicije'
start <- as.vector(t(which(maze_matrix == 'S', arr.ind = TRUE)))
exit <- as.vector(t(which(maze_matrix == 'E', arr.ind = TRUE)))
current = start
'Gremo skozi celoten vektor (po 2 bita pretvorimo v move) in spreminjamo trenutno lokacijo, ter preverjamo veljavnost koraka'
for (i in seq(1,length(path), 2)) {
'We get the next move'
move <- path[c(i:i+1)]
'We adjust the current position accordingly'
if(all(move == c(0,0))){ "UP"
current <- current - c(1,0)
} else if(all(move == c(0,1))){ "RIGHT"
current <- current + c(0,1)
} else if(all(move == c(1,0))){ "DOWN"
current <- current + c(1,0)
} else if(all(move == c(1,1))){ "LEFT"
current <- current - c(0,1)
} else{
print("Error")
}
if(!all(current > 0) || !all(current < dim(maze_matrix) || maze_matrix(current[1], current[2]) == '#')){
'We are either out of a matrix or on a wall'
'We can add if we get to "S" which would mean we are going in a loop and its not the shortest position'
'We can give all enteties 0 if this happens or we can count how many walls they go through and give a value based on that'
print("INVALID MOVE")
}
if(maze_matrix[current[1], current[2]] == 'E'){
print("MADE IT TO THE FINISH")
break
}
}
'All moves were done or we got to the exit'
print(current)
}
maze1 = c("##E##",
"#...#",
"#...#",
"#S..#",
"#####")
maze_matrix <- map_reading(maze1)
maze_matrix
my_path <- c(0,0,0,1,0,0,0,0)
stats(my_path, maze1)
debugger(stats)
debugger(stats)
debug(stats)
stats(my_path,maze1)
debug(stats)
stats(my_path,maze1)
maze_matrix[current[1],current[2]]
dim(maze_matrix)
path[i:i+1]
path[i:i+2]
path[c(i:i+1)]
path[c(i:i+2)]
path[c(i:i+3)]
path[c(i:i+4)]
path[1:3]
path[i:i + 3]
i
i+ 1
path[i]
path[i-1]
path[i-1:i+1]
path[i:i+1]
path[i:i+2]
path[i:i+3]
path[1:4]
i = 1
path[i:4]
path[i: i + 1]
path[i:(i+1)]
path[i:(i+4)]
path[i:(i+4)]
temp = c(4,2)
temp <- temp - c(1,0)
temp
v <- c(1,0)
v
v == c(1,0)
path <- c(0,0,0,1,0,0,0,0)
library(GA)
map_reading <- function(maze){
'In mazer.r all mazes are square shaped so we might only need the rows parameter'
rows = length(maze)
columns = nchar(maze[1])
'We initialize an empty matrix of the correct dimensions'
maze_matrix = matrix(, nrow = rows, ncol = columns)
'We fill the matrix with correct values'
for (i in c(1:rows)) {
maze_matrix[i,] <- unlist(strsplit(maze[i], ""))
}
return (maze_matrix)
}
stats <- function(path, maze){
maze_matrix = map_reading(maze)
'Dobimo vektor koordinat zacetne pozicije'
start <- as.vector(t(which(maze_matrix == 'S', arr.ind = TRUE)))
exit <- as.vector(t(which(maze_matrix == 'E', arr.ind = TRUE)))
current = start
'Gremo skozi celoten vektor (po 2 bita pretvorimo v move) in spreminjamo trenutno lokacijo, ter preverjamo veljavnost koraka'
for (i in seq(1,length(path), 2)) {
'We get the next move'
move <- path[i : (i+1)]
'We adjust the current position accordingly'
if(all(move == c(0,0))){ "UP"
current <- current - c(1,0)
} else if(all(move == c(0,1))){ "RIGHT"
current <- current + c(0,1)
} else if(all(move == c(1,0))){ "DOWN"
current <- current + c(1,0)
} else if(all(move == c(1,1))){ "LEFT"
current <- current - c(0,1)
} else{
print("Error")
}
if(!all(current > 0) || !all(current < dim(maze_matrix) || maze_matrix(current[1], current[2]) == '#')){
'We are either out of a matrix or on a wall'
'We can add if we get to "S" which would mean we are going in a loop and its not the shortest position'
'We can give all enteties 0 if this happens or we can count how many walls they go through and give a value based on that'
print("INVALID MOVE")
}
if(maze_matrix[current[1], current[2]] == 'E'){
print("MADE IT TO THE FINISH")
break
}
}
'All moves were done or we got to the exit'
print(current)
}
debug(stats)
maze1 = c("##E##",
"#...#",
"#...#",
"#S..#",
"#####")
stats(path, maze1)
path <- c(0,0,0,0,0,0,0,0)
stats(path, maze1)
debug(stats)
undebug(stats)
maze_matrix(current)
stats(path, maze1)
debug(stats)
stats(path, maze1)
map_reading <- function(maze){
'In mazer.r all mazes are square shaped so we might only need the rows parameter'
rows = length(maze)
columns = nchar(maze[1])
'We initialize an empty matrix of the correct dimensions'
maze_matrix = matrix(, nrow = rows, ncol = columns)
'We fill the matrix with correct values'
for (i in c(1:rows)) {
maze_matrix[i,] <- unlist(strsplit(maze[i], ""))
}
return (maze_matrix)
}
stats <- function(path, maze){
maze_matrix = map_reading(maze)
'Dobimo vektor koordinat zacetne pozicije'
start <- as.vector(t(which(maze_matrix == 'S', arr.ind = TRUE)))
exit <- as.vector(t(which(maze_matrix == 'E', arr.ind = TRUE)))
current = start
'Gremo skozi celoten vektor (po 2 bita pretvorimo v move) in spreminjamo trenutno lokacijo, ter preverjamo veljavnost koraka'
for (i in seq(1,length(path), 2)) {
'We get the next move'
move <- path[i : (i+1)]
'We adjust the current position accordingly'
if(all(move == c(0,0))){ "UP"
current <- current - c(1,0)
} else if(all(move == c(0,1))){ "RIGHT"
current <- current + c(0,1)
} else if(all(move == c(1,0))){ "DOWN"
current <- current + c(1,0)
} else if(all(move == c(1,1))){ "LEFT"
current <- current - c(0,1)
} else{
print("Error")
}
if(!all(current > 0) || !all(current < dim(maze_matrix) || maze_matrix[current[1], current[2]] == '#')){
'We are either out of a matrix or on a wall'
'We can add if we get to "S" which would mean we are going in a loop and its not the shortest position'
'We can give all enteties 0 if this happens or we can count how many walls they go through and give a value based on that'
print("INVALID MOVE")
break
}
if(maze_matrix[current[1], current[2]] == 'E'){
print("MADE IT TO THE FINISH")
break
}
}
'All moves were done or we got to the exit'
print(current)
}
debug(stats)
stats(path,maze1)
maze_matrix[current[1], current[2]]
maze_matrix[current[1], current[2]] == '#'
!all(current > 0)
!all(current < dim(maze_matrix)
stats <- function(path, maze){
maze_matrix = map_reading(maze)
'Dobimo vektor koordinat zacetne pozicije'
start <- as.vector(t(which(maze_matrix == 'S', arr.ind = TRUE)))
exit <- as.vector(t(which(maze_matrix == 'E', arr.ind = TRUE)))
current = start
'Gremo skozi celoten vektor (po 2 bita pretvorimo v move) in spreminjamo trenutno lokacijo, ter preverjamo veljavnost koraka'
for (i in seq(1,length(path), 2)) {
'We get the next move'
move <- path[i : (i+1)]
'We adjust the current position accordingly'
if(all(move == c(0,0))){ "UP"
current <- current - c(1,0)
} else if(all(move == c(0,1))){ "RIGHT"
current <- current + c(0,1)
} else if(all(move == c(1,0))){ "DOWN"
current <- current + c(1,0)
} else if(all(move == c(1,1))){ "LEFT"
current <- current - c(0,1)
} else{
print("Error")
}
if(!all(current > 0) || !all(current < dim(maze_matrix)) || maze_matrix[current[1], current[2]] == '#'){
'We are either out of a matrix or on a wall'
'We can add if we get to "S" which would mean we are going in a loop and its not the shortest position'
'We can give all enteties 0 if this happens or we can count how many walls they go through and give a value based on that'
print("INVALID MOVE")
break
}
if(maze_matrix[current[1], current[2]] == 'E'){
print("MADE IT TO THE FINISH")
break
}
}
'All moves were done or we got to the exit'
print(current)
}
undebug(stats)
stats <- function(path, maze){
maze_matrix = map_reading(maze)
'Dobimo vektor koordinat zacetne pozicije'
start <- as.vector(t(which(maze_matrix == 'S', arr.ind = TRUE)))
exit <- as.vector(t(which(maze_matrix == 'E', arr.ind = TRUE)))
current = start
'Gremo skozi celoten vektor (po 2 bita pretvorimo v move) in spreminjamo trenutno lokacijo, ter preverjamo veljavnost koraka'
for (i in seq(1,length(path), 2)) {
'We get the next move'
move <- path[i : (i+1)]
'We adjust the current position accordingly'
if(all(move == c(0,0))){ "UP"
current <- current - c(1,0)
} else if(all(move == c(0,1))){ "RIGHT"
current <- current + c(0,1)
} else if(all(move == c(1,0))){ "DOWN"
current <- current + c(1,0)
} else if(all(move == c(1,1))){ "LEFT"
current <- current - c(0,1)
} else{
print("Error")
}
if(!all(current > 0) || !all(current < dim(maze_matrix)) || maze_matrix[current[1], current[2]] == '#'){
'We are either out of a matrix or on a wall'
'We can add if we get to "S" which would mean we are going in a loop and its not the shortest position'
'We can give all enteties 0 if this happens or we can count how many walls they go through and give a value based on that'
print("INVALID MOVE")
break
}
if(maze_matrix[current[1], current[2]] == 'E'){
print("MADE IT TO THE FINISH")
break
}
}
'All moves were done or we got to the exit'
print(current)
}
debug(stats)
stats(path, maze1)
